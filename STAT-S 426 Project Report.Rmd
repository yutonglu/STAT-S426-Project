---
title: |
  | Project Report
  | Baysien Option Pricing Using Mixed Normal Heteroskedasticity Models
author: "Ashley Lu, Liang Zou"
date: "11/28/2017"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
library(coda)

```


```{r load data}

setwd("~/Desktop/STAT-S 426/STAT-S426-Project")
SP500.2006 <- read.csv("2006.txt",header = F)
SP500.2007 <- read.csv("2007.txt",header = F)
SP500 <- rbind(SP500.2006,SP500.2007)

R = c()
for (i in 2:nrow(SP500)){
  R = c(R, log(SP500$V2[i]/SP500$V2[i-1]))
}

```



```{r plot of R}
plot(R, type = 'l')
boxplot(R, las = 1)
summary(R)

plot(density(R),las = 1, xlab = 'R')
abline(v = 0.008, col = 3)
abline(v = -0.001, col = 5)

length(subset(R, R > 0.009))
# length(subset(R, R > 0.003 & R < 0.011))

length(subset(R, R > -0.002 & R < 0.009))
length(subset(R, R < -0.002))

```
    
    
    
    
```{r prior of mixture}
# K = # of mixture normal models 
# T = total # of days
# pi = proportion of each normal model
# mu = mean of each normal
# theta = variance of each normal
# v_t ~ Uniform[0,1]
# Gt = k -> which normal model

mu = c(0.008, -0.003)
s2 = c(0.0001, 0.0001)
p = c(0.6, 0.4)
K = 2 # the number of mixed normal models

x = seq(-0.04,0.04,0.0001)
plot(x, p[1]*dnorm(x, mu[1], sqrt(s2[1])) + p[2]*dnorm(x, mu[2], sqrt(s2[2])), 
      ylab = expression(p(theta)), xlab = expression(theta), type = 'l')
lines(density(R),col='green')

```




```{r MCMC}

th = R[1] # the first day of R (i.e. 1/4/2006)
THD.MCMC <- NULL
S <- length(R) - 1

for(s in 1:S) {
  pz.unnorm <- p*dnorm(th, mu, sqrt(s2))
  z <- sample(1:K ,1, prob=pz.unnorm) 
    # Note that the sample() function in R normalizes the weights in pz.unnorm. 
    # Otherwise we would have to do it by hand.
  th <- rnorm(1, mu[z], sqrt(s2[z]))
  THD.MCMC <- rbind(THD.MCMC, c(th,z))
}



```




```{r diagnostics}

plot(R[-1], type = 'l', las = 1, ylab = 'R', col = 'green')

lines(THD.MCMC[,1], type = 'l', col = 'red')

legend('bottomleft',legend = c("Real data", 'MCMC prediction'), lty = c(1,1), col = c('green','red'))

error = 1/S*sum((R[-1]-THD.MCMC[,1])^2)
round(error,6)

```


```{r acf effective sample size and plot}
acf(THD.MCMC[,1],lag.max=100, main = 'MCMC')

effectiveSize(THD.MCMC[,1])

thd.mcmc <- mcmc(THD.MCMC[,1])
# summary(thd.mcmc)
plot(thd.mcmc, las = 1)

```




